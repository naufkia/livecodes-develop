"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
const Emitter_1 = __importDefault(require("licia/Emitter"));
const getProto_1 = __importDefault(require("licia/getProto"));
const isNum_1 = __importDefault(require("licia/isNum"));
const isBool_1 = __importDefault(require("licia/isBool"));
const lowerCase_1 = __importDefault(require("licia/lowerCase"));
const isObj_1 = __importDefault(require("licia/isObj"));
const isArr_1 = __importDefault(require("licia/isArr"));
const upperFirst_1 = __importDefault(require("licia/upperFirst"));
const keys_1 = __importDefault(require("licia/keys"));
const each_1 = __importDefault(require("licia/each"));
const toSrc_1 = __importDefault(require("licia/toSrc"));
const isPromise_1 = __importDefault(require("licia/isPromise"));
const type_1 = __importDefault(require("licia/type"));
const _1 = __importDefault(require("licia/$"));
const difference_1 = __importDefault(require("licia/difference"));
const allKeys_1 = __importDefault(require("licia/allKeys"));
const filter_1 = __importDefault(require("licia/filter"));
const chunk_1 = __importDefault(require("licia/chunk"));
const toStr_1 = __importDefault(require("licia/toStr"));
const noop_1 = __importDefault(require("licia/noop"));
const Visitor_1 = __importDefault(require("./Visitor"));
const util_1 = require("./util");
const Static_1 = __importDefault(require("./Static"));
const util_2 = require("../share/util");
const c = util_2.classPrefix('object-viewer');
function getObjAbstract(data, type) {
    if (!type)
        return;
    if (type === 'Function') {
        return util_1.getFnAbstract(toSrc_1.default(data));
    }
    if (type === 'Array') {
        return `Array(${data.length})`;
    }
    return type;
}
module.exports = (_a = class ObjectViewer extends Emitter_1.default {
        constructor(container, { unenumerable = false, accessGetter = false } = {}) {
            super();
            this.onItemClick = (e) => {
                const { map } = this;
                const $this = _1.default(e.curTarget);
                const circularId = $this.data('object-id');
                const $firstSpan = $this.find('span').eq(0);
                if ($this.data('first-level'))
                    return;
                if (circularId) {
                    $this.find('ul').html(this.objToHtml(map[circularId], false));
                    $this.rmAttr('data-object-id');
                }
                e.stopImmediatePropagation();
                if (!$firstSpan.hasClass(c('expanded')))
                    return;
                const $ul = $this.find('ul').eq(0);
                if ($firstSpan.hasClass(c('collapsed'))) {
                    $firstSpan.rmClass(c('collapsed'));
                    $ul.show();
                }
                else {
                    $firstSpan.addClass(c('collapsed'));
                    $ul.hide();
                }
                this.emit('change');
            };
            this.$container = _1.default(container);
            this.$container.addClass('luna-object-viewer');
            this.unenumerable = unenumerable;
            this.accessGetter = accessGetter;
            this.bindEvent();
        }
        set(data) {
            this.data = [data];
            this.visitor = new Visitor_1.default();
            this.map = {};
            this.appendTpl();
        }
        destroy() {
            this.$container.off('click', 'li', this.onItemClick);
            this.$container.rmClass('luna-object-viewer');
            this.$container.html('');
        }
        objToHtml(data, firstLevel) {
            const { visitor } = this;
            let self = data;
            let isBigArr = false;
            const visitedObj = visitor.get(data);
            if (visitedObj && visitedObj.self) {
                self = visitedObj.self;
            }
            let ret = '';
            const types = ['enumerable'];
            let enumerableKeys = keys_1.default(data);
            let unenumerableKeys = [];
            let symbolKeys = [];
            let virtualKeys = [];
            const virtualData = {};
            if (this.unenumerable && !firstLevel) {
                types.push('unenumerable');
                types.push('symbol');
                unenumerableKeys = difference_1.default(allKeys_1.default(data, {
                    prototype: false,
                    unenumerable: true,
                }), enumerableKeys);
                symbolKeys = filter_1.default(allKeys_1.default(data, {
                    prototype: false,
                    symbol: true,
                }), (key) => {
                    return typeof key === 'symbol';
                });
            }
            if (isArr_1.default(data) && data.length > 100) {
                types.unshift('virtual');
                isBigArr = true;
                let idx = 0;
                const map = {};
                each_1.default(chunk_1.default(data, 100), (val) => {
                    const obj = Object.create(null);
                    const startIdx = idx;
                    let key = '[' + startIdx;
                    each_1.default(val, (val) => {
                        obj[idx] = val;
                        map[idx] = true;
                        idx++;
                    });
                    const endIdx = idx - 1;
                    key += (endIdx - startIdx > 0 ? ' â€¦ ' + endIdx : '') + ']';
                    virtualData[key] = obj;
                });
                virtualKeys = keys_1.default(virtualData);
                enumerableKeys = filter_1.default(enumerableKeys, (val) => !map[val]);
            }
            each_1.default(types, (type) => {
                let typeKeys = [];
                if (type === 'symbol') {
                    typeKeys = symbolKeys;
                }
                else if (type === 'unenumerable') {
                    typeKeys = unenumerableKeys;
                }
                else if (type === 'virtual') {
                    typeKeys = virtualKeys;
                }
                else {
                    typeKeys = enumerableKeys;
                }
                if (!isBigArr) {
                    typeKeys.sort(util_1.sortObjName);
                }
                for (let i = 0, len = typeKeys.length; i < len; i++) {
                    const key = toStr_1.default(typeKeys[i]);
                    let val = '';
                    const descriptor = Object.getOwnPropertyDescriptor(data, key);
                    const hasGetter = descriptor && descriptor.get;
                    const hasSetter = descriptor && descriptor.set;
                    if (hasGetter && !this.accessGetter) {
                        val = '(...)';
                    }
                    else {
                        try {
                            if (type === 'virtual') {
                                val = virtualData[key];
                            }
                            else {
                                val = self[key];
                            }
                            if (isPromise_1.default(val)) {
                                ;
                                val.catch(noop_1.default);
                            }
                        }
                        catch (e) {
                            val = e.message;
                        }
                    }
                    ret += this.createEl(key, data, val, type, firstLevel);
                    if (hasGetter) {
                        ret += this.createEl(`get ${key}`, data, descriptor.get, type, firstLevel);
                    }
                    if (hasSetter) {
                        ret += this.createEl(`set ${key}`, data, descriptor.set, type, firstLevel);
                    }
                }
            });
            const proto = getProto_1.default(data);
            if (!firstLevel && proto) {
                if (ret === '') {
                    const id = visitor.set(proto, {
                        self: data,
                    });
                    this.map[id] = proto;
                    ret = this.objToHtml(proto);
                }
                else {
                    ret += this.createEl('__proto__', self || data, proto, 'proto');
                }
            }
            return ret;
        }
        createEl(key, self, val, keyType, firstLevel = false) {
            const { visitor } = this;
            let t = typeof val;
            let valType = type_1.default(val, false);
            if (keyType === 'virtual')
                valType = key;
            if (val === null) {
                return `<li>${wrapKey(key)}<span class="${c('null')}">null</span></li>`;
            }
            else if (isNum_1.default(val) || isBool_1.default(val)) {
                return `<li>${wrapKey(key)}<span class="${c(t)}">${util_1.encode(val)}</span></li>`;
            }
            if (valType === 'RegExp')
                t = 'regexp';
            if (valType === 'Number')
                t = 'number';
            if (valType === 'Number' || valType === 'RegExp') {
                return `<li>${wrapKey(key)}<span class="${c(t)}">${util_1.encode(val.value)}</span></li>`;
            }
            else if (valType === 'Undefined' || valType === 'Symbol') {
                return `<li>${wrapKey(key)}<span class="${c('special')}">${lowerCase_1.default(valType)}</span></li>`;
            }
            else if (val === '(...)') {
                return `<li>${wrapKey(key)}<span class="${c('special')}">${val}</span></li>`;
            }
            else if (isObj_1.default(val)) {
                const visitedObj = visitor.get(val);
                let id;
                if (visitedObj) {
                    id = visitedObj.id;
                }
                else {
                    const extra = {};
                    if (keyType === 'proto') {
                        extra.self = self;
                    }
                    id = visitor.set(val, extra);
                    this.map[id] = val;
                }
                const objAbstract = getObjAbstract(val, valType) || upperFirst_1.default(t);
                const icon = firstLevel
                    ? ''
                    : `<span class="${c('expanded collapsed')}"><span class="${c('icon icon-caret-right')}"></span><span class="${c('icon icon-caret-down')}"></span></span>`;
                let obj = `<li ${firstLevel ? 'data-first-level="true"' : ''} ${'data-object-id="' + id + '"'}>${icon}${wrapKey(key)}<span class="${c('open')}">${firstLevel ? '' : objAbstract}</span><ul class="${c(t)}" ${firstLevel ? '' : 'style="display:none"'}>`;
                if (firstLevel)
                    obj += this.objToHtml(val);
                return obj + `</ul><span class="${c('close')}"></span></li>`;
            }
            function wrapKey(key) {
                if (firstLevel)
                    return '';
                if (isObj_1.default(val) && keyType === 'virtual')
                    return '';
                let keyClass = c('key');
                if (keyType === 'unenumerable' ||
                    keyType === 'proto' ||
                    keyType === 'symbol') {
                    keyClass = c('key-lighter');
                }
                return `<span class="${keyClass}">${util_1.encode(key)}</span>: `;
            }
            return `<li>${wrapKey(key)}<span class="${c(typeof val)}">"${util_1.encode(val)}"</span></li>`;
        }
        appendTpl() {
            this.$container.html(this.objToHtml(this.data, true));
        }
        bindEvent() {
            this.$container.on('click', 'li', this.onItemClick);
        }
    },
    _a.Static = Static_1.default,
    _a);
