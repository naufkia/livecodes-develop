import { Prec, StateEffect, StateField, MapMode, EditorSelection } from '@codemirror/state';
import { EditorView, Direction, ViewPlugin, showPanel } from '@codemirror/view';
import * as commands from '@codemirror/commands';
import { startCompletion } from '@codemirror/autocomplete';
import { openSearchPanel } from '@codemirror/search';

class Piece {
    constructor(left, top, height, className, letter, partial) {
        this.left = left;
        this.top = top;
        this.height = height;
        this.className = className;
        this.letter = letter;
        this.partial = partial;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        elt.style.height = this.height + "px";
        elt.style.lineHeight = this.height + "px";
        elt.style.color = this.partial ? "transparent" : "";
        elt.className = this.className;
        elt.textContent = this.letter;
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.letter == p.letter && this.height == p.height &&
            this.className == p.className;
    }
}
class BlockCursorPlugin {
    constructor(view) {
        this.view = view;
        this.rangePieces = [];
        this.cursors = [];
        this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
        this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
        this.cursorLayer.className = "cm-cursorLayer cm-vimCursorLayer";
        this.cursorLayer.setAttribute("aria-hidden", "true");
        view.requestMeasure(this.measureReq);
        this.setBlinkRate();
    }
    setBlinkRate() {
        this.cursorLayer.style.animationDuration = 1200 + "ms";
    }
    update(update) {
        if (update.selectionSet || update.geometryChanged || update.viewportChanged) {
            this.view.requestMeasure(this.measureReq);
            this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        }
    }
    scheduleRedraw() {
        this.view.requestMeasure(this.measureReq);
    }
    readPos() {
        let { state } = this.view;
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            let piece = measureCursor(null, this.view, r, prim);
            if (piece)
                cursors.push(piece);
        }
        return { cursors };
    }
    drawSel({ cursors }) {
        if (cursors.length != this.cursors.length || cursors.some((c, i) => !c.eq(this.cursors[i]))) {
            let oldCursors = this.cursorLayer.children;
            if (oldCursors.length !== cursors.length) {
                this.cursorLayer.textContent = "";
                for (const c of cursors)
                    this.cursorLayer.appendChild(c.draw());
            }
            else {
                cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
            }
            this.cursors = cursors;
        }
    }
    destroy() {
        this.cursorLayer.remove();
    }
}
const themeSpec = {
    ".cm-line": {
        "& ::selection": { backgroundColor: "transparent !important" },
        "&::selection": { backgroundColor: "transparent !important" },
        caretColor: "transparent !important",
    },
    ".cm-fat-cursor": {
        position: "absolute",
        background: "#ff9696",
        border: "none",
        whiteSpace: "pre",
    },
    "&:not(.cm-focused) .cm-fat-cursor": {
        background: "none",
        outline: "solid 1px #ff9696"
    },
};
const hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
}
function measureCursor(cm, view, cursor, primary) {
    let head = cursor.head;
    var hCoeff = 1;
    let pos = view.coordsAtPos(head, cursor.assoc || 1);
    if (!pos)
        return null;
    let base = getBase(view);
    let letter = head < view.state.doc.length && view.state.sliceDoc(head, head + 1);
    if (!letter || letter == "\n" || letter == "\r")
        letter = "\xa0";
    let h = (pos.bottom - pos.top);
    return new Piece(pos.left - base.left, pos.top - base.top + h * (1 - hCoeff), h * hCoeff, primary ? "cm-fat-cursor cm-cursor-primary" : "cm-fat-cursor cm-cursor-secondary", letter, hCoeff != 1);
}

const emacsStyle = /*@__PURE__*/EditorView.theme({
    ".cm-emacsMode .cm-cursorLayer:not(.cm-vimCursorLayer)": {
        display: "none",
    },
    ".cm-vim-panel": {
        padding: "5px 10px",
        backgroundColor: "#fffa8f",
        fontFamily: "monospace",
    },
    ".cm-vim-panel input": {
        border: "none",
        outline: "none",
        backgroundColor: "#fffa8f",
    },
});
const emacsPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {
    constructor(view) {
        this.status = "";
        this.view = view;
        this.em = new EmacsHandler(view);
        this.blockCursor = new BlockCursorPlugin(view);
        this.view.scrollDOM.classList.add("cm-emacsMode");
        /*this.em.on("dialog", () => {
          view.dispatch({
            effects: showEmacsPanel.of(!!this.cm.state.dialog)
          })
        });*/
    }
    update(update) {
        if (update.docChanged) {
            this.em.$emacsMark = null;
            this.em.updateMarksOnChange(update.changes);
        }
        /*if (update.selectionSet) {
          this.em.onSelectionChange()
        }
        if (update.viewportChanged) {
          // scroll
        }
        if (this.em.curOp && !this.em.curOp.isVimOp) {
          this.em.onBeforeEndOperation();
        }/**/
        this.blockCursor.update(update);
    }
    destroy() {
        this.view.scrollDOM.classList.remove("cm-emacsMode");
        this.blockCursor.destroy();
    }
}, {
    eventHandlers: {
        keydown: function (e, view) {
            var result = this.em.handleKeyboard(e);
            return !!result;
        },
        mousedown: function () {
            this.em.$emacsMark = null;
        }
    }
});
const showVimPanel = /*@__PURE__*/StateEffect.define();
const vimPanelState = /*@__PURE__*/StateField.define({
    create: () => false,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(showVimPanel))
                value = e.value;
        return value;
    },
    provide: f => {
        return showPanel.from(f, on => on ? createVimPanel : null);
    }
});
function createVimPanel(view) {
    let dom = document.createElement("div");
    dom.className = "cm-vim-panel";
    return { top: false, dom };
}
function emacs(options = {}) {
    return [
        emacsStyle,
        emacsPlugin,
        hideNativeSelection,
        vimPanelState
    ];
}
var specialKey = {
    Return: 'Return', Escape: 'Esc', Insert: 'Ins',
    ArrowLeft: 'Left', ArrowRight: 'Right', ArrowUp: 'Up', ArrowDown: 'Down',
    Enter: 'Return', Divide: '/', Slash: '/', Multiply: '*',
    Subtract: '-', Minus: "-", Equal: '=',
};
var ignoredKeys = { Shift: 1, Alt: 1, Command: 1, Control: 1, CapsLock: 1 };
const commandKeyBinding = {};
class EmacsHandler {
    constructor(view) {
        this.view = view;
        // commands
        this.$data = {
            count: 0,
            keyChain: "",
            lastCommand: ""
        };
        // mark
        this.$emacsMarkRing = [];
        this.$emacsMark = null;
    }
    static bindKey(keyGroup, command) {
        keyGroup.split("|").forEach(function (binding) {
            let chain = "";
            let parts = binding.split(/\s+/);
            parts.forEach(function (keyGroup, index) {
                let modifiers = keyGroup.split(/-(?=.)/);
                let key = modifiers.pop();
                if (modifiers.length) {
                    chain += modifiers.sort().join("-") + "-";
                }
                chain += key;
                if (index === parts.length - 1) {
                    commandKeyBinding[chain] = command;
                }
                else {
                    commandKeyBinding[chain] = "null";
                    chain += " ";
                }
            });
        });
    }
    static getKey(e) {
        var code = e.code;
        var key = e.key;
        if (ignoredKeys[key])
            return ['', '', ''];
        if (code.length > 1) {
            if (code[0] == "N")
                code = code.replace(/^Numpad/, "");
            if (code[0] == "K")
                code = code.replace(/^Key/, "");
        }
        code = specialKey[code] || code;
        if (code.length == 1)
            code = code.toLowerCase();
        var modifier = '';
        if (e.ctrlKey) {
            modifier += 'C-';
        }
        if (e.metaKey) {
            modifier += 'CMD-';
        }
        if (e.altKey) {
            modifier += 'M-';
        }
        if (e.shiftKey) {
            modifier += 'S-';
        }
        return [code, modifier, key];
    }
    static addCommands(commands) {
        Object.keys(commands).forEach(function (name) {
            var command = commands[name];
            if (typeof command == "function") {
                command = { exec: command };
            }
            EmacsHandler.commands[name] = command;
        });
    }
    static execCommand(command, handler, args, count = 1) {
        var commandResult = undefined;
        if (typeof command === "function") {
            for (var i = 0; i < count; i++)
                command(handler.view);
        }
        else if (command === "null") ;
        else if (command.exec) {
            if (count > 1 && command.handlesCount) {
                if (!args)
                    args = {};
                if (typeof args === 'object')
                    args.count = count;
                count = 1;
            }
            for (var i = 0; i < count; i++)
                commandResult = command.exec(handler, args || {});
        }
        else {
            throw new Error("missformed command");
        }
        return commandResult;
    }
    ;
    handleKeyboard(e) {
        var keyData = EmacsHandler.getKey(e);
        var result = this.findCommand(keyData);
        if (result && result.command) {
            var commandResult = EmacsHandler.execCommand(result.command, this, result.args, result.count);
            if (commandResult === false)
                return;
        }
        return result;
    }
    findCommand([key, modifier, text]) {
        // if keyCode == -1 a non-printable key was pressed, such as just
        // control. Handling those is currently not supported in this handler
        if (!key)
            return undefined;
        var editor = this;
        var data = this.$data;
        // editor._signal("changeStatus");
        // insertstring data.count times
        if (!modifier && key.length == 1) {
            editor.pushEmacsMark();
            if (data.count) {
                var str = new Array(data.count + 1).join(text);
                data.count = null;
                return { command: "insertstring", args: str };
            }
        }
        // CTRL + number / universalArgument for setting data.count
        if (modifier == "C-" || data.count) {
            var count = parseInt(key[key.length - 1]);
            if (typeof count === 'number' && !isNaN(count)) {
                data.count = Math.max(data.count || 0, 0);
                data.count = 10 * data.count + count;
                return { command: "null" };
            }
        }
        // this.commandKeyBinding maps key specs like "c-p" (for CTRL + P) to
        // command objects, for lookup key needs to include the modifier
        if (modifier)
            key = modifier + key;
        // Key combos like CTRL+X H build up the data.keyChain
        if (data.keyChain)
            key = data.keyChain += " " + key;
        // Key combo prefixes get stored as "null" (String!) in this
        // this.commandKeyBinding. When encountered no command is invoked but we
        // buld up data.keyChain
        var command = commandKeyBinding[key];
        data.keyChain = command == "null" ? key : "";
        // there really is no command
        if (!command)
            return undefined;
        // we pass b/c of key combo or universalArgument
        if (command === "null")
            return { command: "null" };
        if (command === "universalArgument") {
            // if no number pressed emacs repeats action 4 times.
            // minus sign is needed to allow next keypress to replace it
            data.count = -4;
            return { command: "null" };
        }
        // lookup command
        // TODO extract special handling of markmode
        // TODO special case command.command is really unnecessary, remove
        var args;
        if (typeof command !== "string") {
            args = command.args;
            if (command.command)
                command = command.command;
        }
        if (command === "insertstring" ||
            command === commands.splitLine ||
            command === commands.toggleComment) {
            editor.pushEmacsMark();
        }
        if (typeof command === "string") {
            command = EmacsHandler.commands[command];
            if (!command)
                return undefined;
        }
        if (!command.readOnly && !command.isYank)
            data.lastCommand = null;
        var count = data.count || 1;
        if (data.count)
            data.count = 0;
        return { command, args, count };
    }
    showCommandLine(text) {
        console.error("TODO");
    }
    updateMarksOnChange(change) {
        if (this.$emacsMark) {
            this.$emacsMark = this.updateMark(this.$emacsMark, change);
        }
        this.$emacsMarkRing = this.$emacsMarkRing.map(x => {
            return this.updateMark(x, change);
        }).filter(Boolean);
    }
    updateMark(mark, change) {
        if (!mark)
            return;
        var updated = mark.map(function (x) {
            return change.mapPos(x, 1, MapMode.TrackDel);
        }).filter(x => x != null);
        return updated.length == 0 ? null : updated;
    }
    emacsMark() {
        return this.$emacsMark;
    }
    ;
    setEmacsMark(p) {
        // to deactivate pass in a falsy value
        this.$emacsMark = p;
    }
    ;
    pushEmacsMark(p, activate) {
        var prevMark = this.$emacsMark;
        if (prevMark)
            this.$emacsMarkRing.push(prevMark);
        if (!p || activate)
            this.setEmacsMark(p);
        else
            this.$emacsMarkRing.push(p);
    }
    ;
    popEmacsMark() {
        var mark = this.emacsMark();
        if (mark) {
            this.setEmacsMark(null);
            return mark;
        }
        return this.$emacsMarkRing.pop();
    }
    ;
    getLastEmacsMark() {
        return this.$emacsMark || this.$emacsMarkRing.slice(-1)[0];
    }
    ;
    getCopyText() {
        var state = this.view.state;
        return state.selection.ranges.map(r => state.sliceDoc(r.from, r.to)).join("\n");
    }
    clearSelection() {
        var view = this.view;
        var selection = view.state.selection;
        var isEmpty = !selection.ranges.some(r => r.from != r.to);
        if (isEmpty)
            return false;
        var newRanges = selection.ranges.map(x => {
            return EditorSelection.range(x.head, x.head);
        });
        view.dispatch({
            selection: EditorSelection.create(newRanges, selection.mainIndex)
        });
        return true;
    }
    onPaste(text) {
        var view = this.view;
        var selection = view.state.selection;
        var linesToInsert;
        if (selection.ranges.length > 1) {
            var lines = text.split("\n");
            if (lines.length == selection.ranges.length) {
                linesToInsert = lines;
            }
        }
        var i = 0;
        var specs = view.state.changeByRange((range) => {
            var toInsert = linesToInsert ? linesToInsert[i] : text;
            i++;
            return {
                changes: { from: range.from, to: range.to, insert: toInsert },
                range: EditorSelection.cursor(range.from + toInsert.length)
            };
        });
        view.dispatch(specs);
    }
}
EmacsHandler.commands = {};
const emacsKeys = {
    // movement
    "Up|C-p": { command: "goOrSelect", args: [commands.cursorLineUp, commands.selectLineUp] },
    "Down|C-n": { command: "goOrSelect", args: [commands.cursorLineDown, commands.selectLineDown] },
    "Left|C-b": { command: "goOrSelect", args: [commands.cursorCharBackward, commands.selectCharBackward] },
    "Right|C-f": { command: "goOrSelect", args: [commands.cursorCharForward, commands.selectCharForward] },
    "C-Left|M-b": { command: "goOrSelect", args: [commands.cursorGroupLeft, commands.selectGroupLeft] },
    "C-Right|M-f": { command: "goOrSelect", args: [commands.cursorGroupRight, commands.selectGroupRight] },
    "Home|C-a": { command: "goOrSelect", args: [commands.cursorLineStart, commands.selectLineStart] },
    "End|C-e": { command: "goOrSelect", args: [commands.cursorLineEnd, commands.selectLineEnd] },
    "C-Home|S-M-,": { command: "goOrSelect", args: [commands.cursorDocStart, commands.selectDocStart] },
    "C-End|S-M-.": { command: "goOrSelect", args: [commands.cursorDocEnd, commands.selectDocEnd] },
    // selection
    "S-Up|S-C-p": commands.selectLineUp,
    "S-Down|S-C-n": commands.selectLineDown,
    "S-Left|S-C-b": commands.selectCharBackward,
    "S-Right|S-C-f": commands.selectCharForward,
    "S-C-Left|S-M-b": commands.selectGroupBackward,
    "S-C-Right|S-M-f": commands.selectGroupForward,
    "S-Home|S-C-a": commands.selectLineStart,
    "S-End|S-C-e": commands.selectLineEnd,
    "S-C-Home": commands.selectDocStart,
    "S-C-End": commands.selectDocEnd,
    "C-l": "recenterTopBottom",
    "M-s": "centerSelection",
    "M-g": "gotoline",
    "C-x C-p|C-x h": commands.selectAll,
    "PageDown|C-v|C-Down": { command: "goOrSelect", args: [commands.cursorPageDown, commands.selectPageDown] },
    "PageUp|M-v|C-Up": { command: "goOrSelect", args: [commands.cursorPageUp, commands.selectPageDown] },
    "S-C-Down": commands.selectPageDown,
    "S-C-Up": commands.selectPageUp,
    // TODO use iSearch
    "C-s": openSearchPanel,
    "C-r": openSearchPanel,
    "M-C-s": "findnext",
    "M-C-r": "findprevious",
    "S-M-5": "replace",
    // basic editing
    "Backspace": commands.deleteCharBackward,
    "Delete|C-d": commands.deleteCharForward,
    "Return|C-m": { command: "insertstring", args: "\n" },
    "C-o": commands.splitLine,
    "M-d|C-Delete": { command: "killWord", args: "right" },
    "C-Backspace|M-Backspace|M-Delete": { command: "killWord", args: "left" },
    "C-k": "killLine",
    "M-h": "selectParagraph",
    "M-@|M-S-2": "markWord",
    "C-y|S-Delete": "yank",
    "M-y": "yankRotate",
    "C-g": "keyboardQuit",
    "C-w|C-S-w": "killRegion",
    "M-w": "killRingSave",
    "C-Space": "setMark",
    "C-x C-x": "exchangePointAndMark",
    "C-t": commands.transposeChars,
    "M-u": { command: "changeCase", args: { dir: 1 } },
    "M-l": { command: "changeCase", args: { dir: -1 } },
    "C-x C-u": { command: "changeCase", args: { dir: 1, region: true } },
    "C-x C-l": { command: "changeCase", args: { dir: 1, region: true } },
    "M-/": startCompletion,
    "C-u": "universalArgument",
    "M-;": commands.toggleComment,
    "C-/|C-x u|S-C--|C-z": commands.undo,
    "S-C-/|S-C-x u|C--|S-C-z": commands.redo,
    // vertical editing
    "C-x r": "selectRectangularRegion",
    "M-x": { command: "focusCommandLine", args: "M-x " },
    // todo
    // "C-x C-t" "M-t" "M-c" "F11" "C-M- "M-q"
    "Esc": "unsetTransientMark"
};
for (let i in emacsKeys) {
    /*@__PURE__*/EmacsHandler.bindKey(i, emacsKeys[i]);
}
/*@__PURE__*/EmacsHandler.addCommands({
    unsetTransientMark: function (handler) {
        handler.setEmacsMark(null);
        return false;
    },
    markWord: function (handler, args) {
    },
    selectParagraph: function (handler, args) {
        var view = handler.view;
        var head = view.state.selection.ranges[0].head;
        var doc = view.state.doc;
        var startLine = doc.lineAt(head);
        var start = -1;
        var end = -1;
        var line = startLine;
        while (/\S/.test(line.text) && line.from > 0) {
            start = line.from;
            line = view.state.doc.lineAt(line.from - 1);
        }
        if (start == -1) {
            while (!/\S/.test(line.text) && line.to < doc.length) {
                start = line.from;
                line = view.state.doc.lineAt(line.to + 1);
            }
        }
        else {
            line = startLine;
        }
        while (/\S/.test(line.text) && line.to < doc.length) {
            end = line.to;
            line = view.state.doc.lineAt(line.to + 1);
        }
        if (end == -1) {
            end = startLine.to;
        }
        var newRanges = [EditorSelection.range(start, end)];
        view.dispatch({
            selection: EditorSelection.create(newRanges)
        });
    },
    goOrSelect: {
        exec: function (handler, args) {
            var command = handler.emacsMark() ? args[1] : args[0];
            command(handler.view);
        }
    },
    changeCase: function (handler, args) {
        var view = handler.view;
        if (!args.region) {
            handler.clearSelection();
            commands.selectGroupForward(view);
        }
        var specs = view.state.changeByRange((range) => {
            var toInsert = view.state.sliceDoc(range.from, range.to);
            toInsert = args.dir == 1 ? toInsert.toUpperCase() : toInsert.toLowerCase();
            return {
                changes: { from: range.from, to: range.to, insert: toInsert },
                range: EditorSelection.cursor(range.from + toInsert.length)
            };
        });
        view.dispatch(specs);
    },
    centerSelection: function (handler) {
        handler.view.dispatch({ scrollIntoView: true });
    },
    recenterTopBottom: function (handler) {
        var view = handler.view;
        var scrollTop = view.scrollDOM.scrollTop;
        view.dispatch({ scrollIntoView: true });
        try {
            // force synchronous measurment
            view.measure(true);
        }
        catch (e) { }
        if (scrollTop != view.scrollDOM.scrollTop)
            return;
        var base = view.scrollDOM.getBoundingClientRect();
        var cursor = view.coordsAtPos(view.state.selection.main.head);
        if (!cursor)
            return;
        var lineHeight = cursor.bottom - cursor.top;
        var screenHeight = base.height;
        var cursorTop = cursor.top - base.top;
        if (Math.abs(cursorTop) < lineHeight / 4) {
            scrollTop += cursorTop + lineHeight - screenHeight + 2;
        }
        else if (Math.abs(cursorTop - screenHeight * 0.5) < lineHeight / 4) {
            scrollTop += cursorTop - 2;
        }
        else {
            scrollTop += cursorTop - screenHeight * 0.5;
        }
        view.scrollDOM.scrollTop = scrollTop;
    },
    selectRectangularRegion: function (handler) {
        var view = handler.view;
        var ranges = view.state.selection.ranges;
        var newRanges = [];
        if (ranges.length > 1) {
            newRanges.push(EditorSelection.range(ranges[0].from, ranges[ranges.length - 1].to));
        }
        else {
            let doc = view.state.doc;
            let startLine = doc.lineAt(ranges[0].from);
            let endLine = doc.lineAt(ranges[0].to);
            let startCollumn = ranges[0].from - startLine.from;
            let endCollumn = ranges[0].to - endLine.from;
            while (startLine.from < endLine.to) {
                newRanges.push(EditorSelection.range(startLine.from + startCollumn, startLine.from + endCollumn));
                if (startLine.to + 1 >= doc.length)
                    break;
                startLine = doc.lineAt(startLine.to + 1);
            }
        }
        view.dispatch({
            selection: EditorSelection.create(newRanges)
        });
    },
    setMark: {
        exec: function (handler, args) {
            var view = handler.view;
            var ranges = view.state.selection.ranges;
            // Sets mark-mode and clears current selection.
            // When mark is set, keyboard cursor movement commands become
            // selection modification commands. That is,
            // "goto" commands become "select" commands.
            // Any insertion or mouse click resets mark-mode.
            // setMark twice in a row at the same place resets markmode.
            // in multi select mode, ea selection is handled individually
            if (args && args.count) {
                var mark = handler.popEmacsMark();
                if (mark) {
                    var newRanges = mark.map((p) => {
                        return EditorSelection.cursor(p, p);
                    });
                    view.dispatch({
                        selection: EditorSelection.create(newRanges)
                    });
                }
                return;
            }
            var mark = handler.emacsMark();
            var rangePositions = ranges.map(function (r) { return r.from; });
            var hasNoSelection = ranges.every(function (range) { return range.from == range.to; });
            // if transientMarkModeActive then mark behavior is a little
            // different. Deactivate the mark when setMark is run with active
            // mark
            if ((mark || !hasNoSelection)) {
                handler.clearSelection();
                if (mark)
                    handler.pushEmacsMark(null);
                return;
            }
            if (!mark) {
                handler.pushEmacsMark(rangePositions);
                handler.setEmacsMark(rangePositions);
                return;
            }
            // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
        },
        readOnly: true,
        handlesCount: true
    },
    exchangePointAndMark: {
        exec: function exchangePointAndMark$exec(handler, args) {
            var view = handler.view;
            var selection = view.state.selection;
            var isEmpty = !selection.ranges.some(r => r.from != r.to);
            if (!args.count && !isEmpty) { // just invert selection
                var newRanges = selection.ranges.map(x => {
                    return EditorSelection.range(x.head, x.anchor);
                });
                view.dispatch({
                    selection: EditorSelection.create(newRanges, selection.mainIndex)
                });
                return;
            }
            var markRing = handler.$emacsMarkRing;
            var lastMark = markRing[markRing.length - 1];
            if (!lastMark)
                return;
            if (args.count) { // replace mark and point
                handler.clearSelection();
                var newRanges = lastMark.map(x => {
                    return EditorSelection.range(x, x);
                });
                view.dispatch({
                    selection: EditorSelection.create(newRanges, selection.mainIndex)
                });
            }
            else { // create selection to last mark
                var n = Math.min(lastMark.length, selection.ranges.length);
                newRanges = [];
                for (var i = 0; i < n; i++) {
                    newRanges.push(EditorSelection.range(selection.ranges[i].head, lastMark[i]));
                }
            }
        },
        readOnly: true,
        handlesCount: true,
    },
    killWord: {
        exec: function (handler, dir) {
            var view = handler.view;
            var selection = view.state.selection;
            var newRanges = selection.ranges.map(x => {
                return EditorSelection.range(x.head, x.head);
            });
            view.dispatch({
                selection: EditorSelection.create(newRanges, selection.mainIndex)
            });
            if (dir == "left")
                commands.selectGroupBackward(view);
            else
                commands.selectGroupForward(view);
            selection = view.state.selection;
            selection.ranges.forEach(r => {
                var text = view.state.sliceDoc(r.from, r.to);
                killRing.add(text);
            });
            view.dispatch(view.state.replaceSelection(""));
        },
    },
    killLine: function (handler) {
        handler.pushEmacsMark(null);
        // don't delete the selection if it's before the cursor
        handler.clearSelection();
        commands.selectLineEnd(handler.view);
        var view = handler.view;
        var state = view.state;
        var text = [];
        var changes = handler.view.state.selection.ranges.map(function (range) {
            var from = range.from;
            var to = range.to;
            var line = state.sliceDoc(from, to);
            text.push(line);
            // remove EOL if only whitespace remains after the cursor
            if (/^\s*$/.test(line)) {
                to += 1;
                text.push("\n");
            }
            return { from, to, insert: "" };
        });
        if (handler.$data.lastCommand == "killLine")
            killRing.append(text.join("\n"));
        else
            killRing.add(text.join("\n"));
        view.dispatch({ changes });
    },
    yank: function (handler) {
        handler.onPaste(killRing.get());
        handler.$data.lastCommand = "yank";
    },
    yankRotate: function (handler) {
        if (handler.$data.lastCommand != "yank")
            return;
        commands.undo(handler.view);
        handler.$emacsMarkRing.pop(); // also undo recording mark
        handler.onPaste(killRing.rotate());
        handler.$data.lastCommand = "yank";
    },
    killRegion: {
        exec: function (handler) {
            killRing.add(handler.getCopyText());
            var view = handler.view;
            view.dispatch(view.state.replaceSelection(""));
            handler.setEmacsMark(null);
        },
    },
    killRingSave: {
        exec: function (handler) {
            var text = handler.getCopyText();
            killRing.add(text);
            handler.clearSelection();
            navigator.clipboard.writeText(text);
        },
        readOnly: true
    },
    keyboardQuit: function (handler) {
        var view = handler.view;
        var selection = view.state.selection;
        var isEmpty = !selection.ranges.some(r => r.from != r.to);
        if (selection.ranges.length > 1 && !isEmpty) {
            var newRanges = selection.ranges.map(x => {
                return EditorSelection.range(x.head, x.head);
            });
            view.dispatch({
                selection: EditorSelection.create(newRanges, selection.mainIndex)
            });
        }
        else {
            commands.simplifySelection(handler.view);
        }
        handler.setEmacsMark(null);
        handler.$data.count = null;
    },
    focusCommandLine: function (handler, arg) {
        handler.showCommandLine(arg);
    }
});
const killRing = {
    $data: [],
    add: function (str) {
        str && this.$data.push(str);
        if (this.$data.length > 30)
            this.$data.shift();
    },
    append: function (str) {
        var idx = this.$data.length - 1;
        var text = this.$data[idx] || "";
        if (str)
            text += str;
        if (text)
            this.$data[idx] = text;
    },
    get: function (n) {
        n = n || 1;
        return this.$data.slice(this.$data.length - n, this.$data.length).reverse().join('\n');
    },
    pop: function () {
        if (this.$data.length > 1)
            this.$data.pop();
        return this.get();
    },
    rotate: function () {
        let last = this.$data.pop();
        if (last)
            this.$data.unshift(last);
        return this.get();
    }
};

export { emacs, emacsKeys };
