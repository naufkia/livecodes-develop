"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pxToNum = exports.executeAfterTransition = exports.hasVerticalScrollbar = exports.measuredScrollbarWidth = exports.eventClient = exports.drag = exports.classPrefix = void 0;
const map_1 = __importDefault(require("licia/map"));
const trim_1 = __importDefault(require("licia/trim"));
const root_1 = __importDefault(require("licia/root"));
const html_1 = __importDefault(require("licia/html"));
const isNum_1 = __importDefault(require("licia/isNum"));
const contain_1 = __importDefault(require("licia/contain"));
const toNum_1 = __importDefault(require("licia/toNum"));
function classPrefix(name) {
    const prefix = `luna-${name}-`;
    function processClass(str) {
        return map_1.default(trim_1.default(str).split(/\s+/), (singleClass) => {
            if (contain_1.default(singleClass, prefix)) {
                return singleClass;
            }
            return singleClass.replace(/[\w-]+/, (match) => `${prefix}${match}`);
        }).join(' ');
    }
    return function (str) {
        if (/<[^>]*>/g.test(str)) {
            try {
                const tree = html_1.default.parse(str);
                traverseTree(tree, (node) => {
                    if (node.attrs && node.attrs.class) {
                        node.attrs.class = processClass(node.attrs.class);
                    }
                });
                return html_1.default.stringify(tree);
            }
            catch (e) {
                return processClass(str);
            }
        }
        return processClass(str);
    };
}
exports.classPrefix = classPrefix;
function traverseTree(tree, handler) {
    for (let i = 0, len = tree.length; i < len; i++) {
        const node = tree[i];
        handler(node);
        if (node.content) {
            traverseTree(node.content, handler);
        }
    }
}
const hasTouchSupport = 'ontouchstart' in root_1.default;
const touchEvents = {
    start: 'touchstart',
    move: 'touchmove',
    end: 'touchend',
};
const mouseEvents = {
    start: 'mousedown',
    move: 'mousemove',
    end: 'mouseup',
};
function drag(name) {
    return hasTouchSupport ? touchEvents[name] : mouseEvents[name];
}
exports.drag = drag;
function eventClient(type, e) {
    const name = type === 'x' ? 'clientX' : 'clientY';
    if (e[name]) {
        return e[name];
    }
    if (e.changedTouches) {
        return e.changedTouches[0][name];
    }
    return 0;
}
exports.eventClient = eventClient;
let scrollbarWidth;
function measuredScrollbarWidth() {
    if (isNum_1.default(scrollbarWidth)) {
        return scrollbarWidth;
    }
    if (!document) {
        return 16;
    }
    const scrollDiv = document.createElement('div');
    const innerDiv = document.createElement('div');
    scrollDiv.setAttribute('style', 'display: block; width: 100px; height: 100px; overflow: scroll;');
    innerDiv.setAttribute('style', 'height: 200px');
    scrollDiv.appendChild(innerDiv);
    document.body.appendChild(scrollDiv);
    scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
}
exports.measuredScrollbarWidth = measuredScrollbarWidth;
function hasVerticalScrollbar(el) {
    return el.scrollHeight > el.offsetHeight;
}
exports.hasVerticalScrollbar = hasVerticalScrollbar;
function executeAfterTransition(el, callback) {
    const handler = (e) => {
        const target = e.target;
        if (target !== el) {
            return;
        }
        el.removeEventListener('transitionend', handler);
        callback();
    };
    el.addEventListener('transitionend', handler);
}
exports.executeAfterTransition = executeAfterTransition;
function pxToNum(str) {
    return toNum_1.default(str.replace('px', ''));
}
exports.pxToNum = pxToNum;
