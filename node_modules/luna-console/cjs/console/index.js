"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Log_1 = __importDefault(require("./Log"));
const isUndef_1 = __importDefault(require("licia/isUndef"));
const perfNow_1 = __importDefault(require("licia/perfNow"));
const now_1 = __importDefault(require("licia/now"));
const isStr_1 = __importDefault(require("licia/isStr"));
const extend_1 = __importDefault(require("licia/extend"));
const uniqId_1 = __importDefault(require("licia/uniqId"));
const isRegExp_1 = __importDefault(require("licia/isRegExp"));
const isFn_1 = __importDefault(require("licia/isFn"));
const Stack_1 = __importDefault(require("licia/Stack"));
const isEmpty_1 = __importDefault(require("licia/isEmpty"));
const contain_1 = __importDefault(require("licia/contain"));
const copy_1 = __importDefault(require("licia/copy"));
const each_1 = __importDefault(require("licia/each"));
const toArr_1 = __importDefault(require("licia/toArr"));
const keys_1 = __importDefault(require("licia/keys"));
const last_1 = __importDefault(require("licia/last"));
const throttle_1 = __importDefault(require("licia/throttle"));
const xpath_1 = __importDefault(require("licia/xpath"));
const lowerCase_1 = __importDefault(require("licia/lowerCase"));
const dateFormat_1 = __importDefault(require("licia/dateFormat"));
const isHidden_1 = __importDefault(require("licia/isHidden"));
const stripIndent_1 = __importDefault(require("licia/stripIndent"));
const util_1 = require("../share/util");
const Component_1 = __importDefault(require("../share/Component"));
const raf = require("licia/raf");
const u = navigator.userAgent;
const isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
const c = util_1.classPrefix('console');
let id = 0;
class Console extends Component_1.default {
    constructor(container, { maxNum = 0, asyncRender = true, showHeader = false, filter = 'all', accessGetter = false, unenumerable = true, lazyEvaluation = true, } = {}) {
        super(container, { compName: 'console' });
        this.spaceHeight = 0;
        this.topSpaceHeight = 0;
        // @ts-ignore
        this.bottomSpaceHeight = 0;
        this.lastScrollTop = 0;
        this.lastTimestamp = 0;
        this.speedToleranceFactor = 100;
        this.maxSpeedTolerance = 2000;
        this.minSpeedTolerance = 100;
        this.logs = [];
        this.displayLogs = [];
        this.timer = {};
        this.counter = {};
        this.asyncList = [];
        this.asyncTimer = null;
        this.isAtBottom = true;
        this.groupStack = new Stack_1.default();
        this.onScroll = () => {
            const { scrollHeight, offsetHeight, scrollTop } = this
                .container;
            // safari bounce effect
            if (scrollTop <= 0)
                return;
            if (offsetHeight + scrollTop > scrollHeight)
                return;
            let isAtBottom = false;
            if (scrollHeight === offsetHeight) {
                isAtBottom = true;
            }
            else if (scrollTop === scrollHeight - offsetHeight) {
                isAtBottom = true;
            }
            this.isAtBottom = isAtBottom;
            const lastScrollTop = this.lastScrollTop;
            const lastTimestamp = this.lastTimestamp;
            const timestamp = now_1.default();
            const duration = timestamp - lastTimestamp;
            const distance = scrollTop - lastScrollTop;
            const speed = Math.abs(distance / duration);
            let speedTolerance = speed * this.speedToleranceFactor;
            if (duration > 1000) {
                speedTolerance = 1000;
            }
            if (speedTolerance > this.maxSpeedTolerance) {
                speedTolerance = this.maxSpeedTolerance;
            }
            if (speedTolerance < this.minSpeedTolerance) {
                speedTolerance = this.minSpeedTolerance;
            }
            this.lastScrollTop = scrollTop;
            this.lastTimestamp = timestamp;
            let topTolerance = 0;
            let bottomTolerance = 0;
            if (lastScrollTop < scrollTop) {
                topTolerance = this.minSpeedTolerance;
                bottomTolerance = speedTolerance;
            }
            else {
                topTolerance = speedTolerance;
                bottomTolerance = this.minSpeedTolerance;
            }
            if (this.topSpaceHeight < scrollTop - topTolerance &&
                this.topSpaceHeight + this.el.offsetHeight >
                    scrollTop + offsetHeight + bottomTolerance) {
                return;
            }
            this.renderViewport({
                topTolerance: topTolerance * 2,
                bottomTolerance: bottomTolerance * 2,
            });
        };
        this.initTpl();
        this.options = {
            maxNum,
            asyncRender,
            showHeader,
            filter,
            accessGetter,
            unenumerable,
            lazyEvaluation,
        };
        this.$el = this.find('.logs');
        this.el = this.$el.get(0);
        this.$fakeEl = this.find('.fake-logs');
        this.fakeEl = this.$fakeEl.get(0);
        this.$space = this.find('.logs-space');
        this.space = this.$space.get(0);
        // For android slowing rendering
        if (isAndroid) {
            this.speedToleranceFactor = 800;
            this.maxSpeedTolerance = 3000;
            this.minSpeedTolerance = 800;
        }
        this.renderViewport = throttle_1.default((options) => {
            this._renderViewport(options);
        }, 16);
        // https://developers.google.cn/web/tools/chrome-devtools/console/utilities
        this.global = {
            copy(value) {
                if (!isStr_1.default(value))
                    value = JSON.stringify(value, null, 2);
                copy_1.default(value);
            },
            $(selectors) {
                return document.querySelector(selectors);
            },
            $$(selectors) {
                return toArr_1.default(document.querySelectorAll(selectors));
            },
            $x(path) {
                return xpath_1.default(path);
            },
            clear: () => {
                this.clear();
            },
            dir: (value) => {
                this.dir(value);
            },
            table: (data, columns) => {
                this.table(data, columns);
            },
            keys: keys_1.default,
        };
        this.bindEvent();
    }
    setGlobal(name, val) {
        this.global[name] = val;
    }
    destroy() {
        super.destroy();
        this.$container.off('scroll', this.onScroll);
    }
    count(label = 'default') {
        const { counter } = this;
        !isUndef_1.default(counter[label]) ? counter[label]++ : (counter[label] = 1);
        this.info(`${label}: ${counter[label]}`);
    }
    countReset(label = 'default') {
        this.counter[label] = 0;
    }
    assert(...args) {
        if (isEmpty_1.default(args))
            return;
        const exp = args.shift();
        if (!exp) {
            if (args.length === 0)
                args.unshift('console.assert');
            args.unshift('Assertion failed: ');
            this.insert('error', args);
        }
    }
    log(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('log', args);
    }
    debug(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('debug', args);
    }
    dir(obj) {
        if (isUndef_1.default(obj))
            return;
        this.insert('dir', [obj]);
    }
    table(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('table', args);
    }
    time(name = 'default') {
        if (this.timer[name]) {
            return this.insert('warn', [`Timer '${name}' already exists`]);
        }
        this.timer[name] = perfNow_1.default();
    }
    timeLog(name = 'default') {
        const startTime = this.timer[name];
        if (!startTime) {
            return this.insert('warn', [`Timer '${name}' does not exist`]);
        }
        this.info(`${name}: ${perfNow_1.default() - startTime}ms`);
    }
    timeEnd(name = 'default') {
        this.timeLog(name);
        delete this.timer[name];
    }
    clear(silent = false) {
        this.logs = [];
        this.displayLogs = [];
        this.lastLog = undefined;
        this.counter = {};
        this.timer = {};
        this.groupStack = new Stack_1.default();
        this.asyncList = [];
        if (this.asyncTimer) {
            clearTimeout(this.asyncTimer);
            this.asyncTimer = null;
        }
        if (silent) {
            this.render();
        }
        else {
            this.insert('log', [
                '%cConsole was cleared',
                'color:#808080;font-style:italic;',
            ]);
        }
    }
    info(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('log', args);
    }
    error(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('error', args);
    }
    warn(...args) {
        if (isEmpty_1.default(args))
            return;
        this.insert('warn', args);
    }
    group(...args) {
        this.insert({
            type: 'group',
            args,
            ignoreFilter: true,
        });
    }
    groupCollapsed(...args) {
        this.insert({
            type: 'groupCollapsed',
            args,
            ignoreFilter: true,
        });
    }
    groupEnd() {
        this.insert('groupEnd');
    }
    evaluate(code) {
        this.insert({
            type: 'input',
            args: [code],
            ignoreFilter: true,
        });
        try {
            this.output(this.evalJs(code));
        }
        catch (e) {
            this.insert({
                type: 'error',
                ignoreFilter: true,
                args: [e],
            });
        }
    }
    html(...args) {
        this.insert('html', args);
    }
    toggleGroup(log) {
        const { targetGroup } = log;
        targetGroup.collapsed
            ? this.openGroup(log)
            : this.collapseGroup(log);
    }
    output(val) {
        this.insert({
            type: 'output',
            args: [val],
            ignoreFilter: true,
        });
    }
    render() {
        const { logs } = this;
        this.$el.html('');
        this.isAtBottom = true;
        this.updateBottomSpace(0);
        this.updateTopSpace(0);
        this.displayLogs = [];
        for (let i = 0, len = logs.length; i < len; i++) {
            this.attachLog(logs[i]);
        }
    }
    insert(type, args) {
        const { showHeader, asyncRender } = this.options;
        let header;
        if (showHeader) {
            header = {
                time: getCurTime(),
                from: getFrom(),
            };
        }
        if (asyncRender) {
            return this.insertAsync(type, args, header);
        }
        this.insertSync(type, args, header);
    }
    insertAsync(type, args, header) {
        this.asyncList.push([type, args, header]);
        this.handleAsyncList();
    }
    insertSync(type, args, header) {
        const { logs, groupStack } = this;
        const { maxNum, accessGetter, unenumerable, lazyEvaluation } = this.options;
        let options;
        if (isStr_1.default(type)) {
            options = {
                type: type,
                args: args,
                header,
            };
        }
        else {
            options = type;
        }
        // Because asynchronous rendering, groupEnd must be put here.
        if (options.type === 'groupEnd') {
            const lastLog = this.lastLog;
            lastLog.groupEnd();
            this.groupStack.pop();
            return;
        }
        if (groupStack.size > 0) {
            options.group = groupStack.peek();
        }
        extend_1.default(options, {
            id: ++id,
            accessGetter,
            unenumerable,
            lazyEvaluation,
        });
        if (options.type === 'group' || options.type === 'groupCollapsed') {
            const group = {
                id: uniqId_1.default('group'),
                collapsed: false,
                parent: groupStack.peek(),
                indentLevel: groupStack.size + 1,
            };
            if (options.type === 'groupCollapsed')
                group.collapsed = true;
            options.targetGroup = group;
            groupStack.push(group);
        }
        let log = new Log_1.default(this, options);
        log.on('updateSize', () => {
            this.isAtBottom = false;
            this.renderViewport();
        });
        const lastLog = this.lastLog;
        if (lastLog &&
            !contain_1.default(['html', 'group', 'groupCollapsed'], log.type) &&
            lastLog.type === log.type &&
            !log.src &&
            !log.args &&
            lastLog.text() === log.text()) {
            lastLog.addCount();
            if (log.header)
                lastLog.updateTime(log.header.time);
            log = lastLog;
            this.detachLog(lastLog);
        }
        else {
            logs.push(log);
            this.lastLog = log;
        }
        if (maxNum !== 0 && logs.length > maxNum) {
            const firstLog = logs[0];
            this.detachLog(firstLog);
            logs.shift();
        }
        this.attachLog(log);
        this.emit('insert', log);
    }
    updateTopSpace(height) {
        this.topSpaceHeight = height;
        this.el.style.top = height + 'px';
    }
    updateBottomSpace(height) {
        this.bottomSpaceHeight = height;
    }
    updateSpace(height) {
        if (this.spaceHeight === height)
            return;
        this.spaceHeight = height;
        this.space.style.height = height + 'px';
    }
    detachLog(log) {
        const { displayLogs } = this;
        const idx = displayLogs.indexOf(log);
        if (idx > -1) {
            displayLogs.splice(idx, 1);
            this.renderViewport();
        }
    }
    // Binary search
    attachLog(log) {
        if (!this.filterLog(log) || log.collapsed)
            return;
        const { displayLogs } = this;
        if (displayLogs.length === 0) {
            displayLogs.push(log);
            this.renderViewport();
            return;
        }
        const lastDisplayLog = last_1.default(displayLogs);
        if (log.id > lastDisplayLog.id) {
            displayLogs.push(log);
            this.renderViewport();
            return;
        }
        let startIdx = 0;
        let endIdx = displayLogs.length - 1;
        let middleLog;
        let middleIdx = 0;
        while (startIdx <= endIdx) {
            middleIdx = startIdx + Math.floor((endIdx - startIdx) / 2);
            middleLog = displayLogs[middleIdx];
            if (middleLog.id === log.id) {
                return;
            }
            if (middleLog.id < log.id) {
                startIdx = middleIdx + 1;
            }
            else {
                endIdx = middleIdx - 1;
            }
        }
        if (middleLog.id < log.id) {
            displayLogs.splice(middleIdx + 1, 0, log);
        }
        else {
            displayLogs.splice(middleIdx, 0, log);
        }
        this.renderViewport();
    }
    handleAsyncList(timeout = 20) {
        const asyncList = this.asyncList;
        if (this.asyncTimer)
            return;
        this.asyncTimer = setTimeout(() => {
            this.asyncTimer = null;
            let done = false;
            const len = asyncList.length;
            // insert faster if logs is huge, thus takes more time to render.
            let timeout, num;
            if (len < 1000) {
                num = 200;
                timeout = 400;
            }
            else if (len < 5000) {
                num = 500;
                timeout = 800;
            }
            else if (len < 10000) {
                num = 800;
                timeout = 1000;
            }
            else if (len < 25000) {
                num = 1000;
                timeout = 1200;
            }
            else if (len < 50000) {
                num = 1500;
                timeout = 1500;
            }
            else {
                num = 2000;
                timeout = 2500;
            }
            if (num > len) {
                num = len;
                done = true;
            }
            for (let i = 0; i < num; i++) {
                const [type, args, header] = asyncList.shift();
                this.insertSync(type, args, header);
            }
            if (!done) {
                raf(() => this.handleAsyncList(timeout));
            }
        }, timeout);
    }
    injectGlobal() {
        each_1.default(this.global, (val, name) => {
            if (window[name])
                return;
            window[name] = val;
        });
    }
    clearGlobal() {
        each_1.default(this.global, (val, name) => {
            if (window[name] && window[name] === val) {
                delete window[name];
            }
        });
    }
    evalJs(jsInput) {
        let ret;
        this.injectGlobal();
        try {
            ret = eval.call(window, `(${jsInput})`);
        }
        catch (e) {
            ret = eval.call(window, jsInput);
        }
        this.setGlobal('$_', ret);
        this.clearGlobal();
        return ret;
    }
    filterLog(log) {
        const { filter } = this.options;
        if (filter === 'all')
            return true;
        if (log.ignoreFilter) {
            return true;
        }
        if (isFn_1.default(filter)) {
            return filter(log);
        }
        if (isRegExp_1.default(filter)) {
            return filter.test(lowerCase_1.default(log.text()));
        }
        return log.type === filter;
    }
    collapseGroup(log) {
        const { targetGroup } = log;
        targetGroup.collapsed = true;
        log.updateIcon('caret-right');
        this.updateGroup(log);
    }
    openGroup(log) {
        const { targetGroup } = log;
        targetGroup.collapsed = false;
        log.updateIcon('caret-down');
        this.updateGroup(log);
    }
    updateGroup(log) {
        const { targetGroup } = log;
        const { logs } = this;
        const len = logs.length;
        let i = logs.indexOf(log) + 1;
        while (i < len) {
            const log = logs[i];
            if (!log.checkGroup() && log.group === targetGroup) {
                break;
            }
            log.collapsed ? this.detachLog(log) : this.attachLog(log);
            i++;
        }
    }
    bindEvent() {
        const { $el } = this;
        $el.on('click', c('.log-container'), function () {
            this.log.click();
        });
        this.on('optionChange', (name, val) => {
            const { logs } = this;
            switch (name) {
                case 'maxNum':
                    if (val > 0 && logs.length > val) {
                        this.logs = logs.slice(logs.length - val);
                        this.render();
                    }
                    break;
                case 'filter':
                    this.render();
                    break;
            }
        });
        this.$container.on('scroll', this.onScroll);
    }
    _renderViewport({ topTolerance = 500, bottomTolerance = 500 } = {}) {
        const { el, container } = this;
        if (isHidden_1.default(container))
            return;
        const { scrollTop, clientWidth, offsetHeight } = container;
        const top = scrollTop - topTolerance;
        const bottom = scrollTop + offsetHeight + bottomTolerance;
        const { displayLogs } = this;
        let topSpaceHeight = 0;
        let bottomSpaceHeight = 0;
        let currentHeight = 0;
        const len = displayLogs.length;
        const { fakeEl } = this;
        const fakeFrag = document.createDocumentFragment();
        const logs = [];
        for (let i = 0; i < len; i++) {
            const log = displayLogs[i];
            const { width, height } = log;
            if (height === 0 || width !== clientWidth) {
                fakeFrag.appendChild(log.container);
                logs.push(log);
            }
        }
        if (logs.length > 0) {
            fakeEl.appendChild(fakeFrag);
            for (let i = 0, len = logs.length; i < len; i++) {
                logs[i].updateSize();
            }
            fakeEl.innerHTML = '';
        }
        const frag = document.createDocumentFragment();
        for (let i = 0; i < len; i++) {
            const log = displayLogs[i];
            const { container, height } = log;
            if (currentHeight > bottom) {
                bottomSpaceHeight += height;
            }
            else if (currentHeight + height > top) {
                frag.appendChild(container);
            }
            else if (currentHeight < top) {
                topSpaceHeight += height;
            }
            currentHeight += height;
        }
        this.updateSpace(currentHeight);
        this.updateTopSpace(topSpaceHeight);
        this.updateBottomSpace(bottomSpaceHeight);
        while (el.firstChild) {
            if (el.lastChild) {
                el.removeChild(el.lastChild);
            }
        }
        el.appendChild(frag);
        const { scrollHeight } = container;
        if (this.isAtBottom && scrollTop <= scrollHeight - offsetHeight) {
            container.scrollTop = 10000000;
        }
    }
    initTpl() {
        this.$container.html(this.c(stripIndent_1.default `
      <div class="logs-space">
        <div class="fake-logs"></div>
        <div class="logs"></div>
      </div>
    `));
    }
}
exports.default = Console;
module.exports = Console;
module.exports.default = Console;
const getCurTime = () => dateFormat_1.default('HH:MM:ss ');
function getFrom() {
    const e = new Error();
    let ret = '';
    const lines = e.stack ? e.stack.split('\n') : '';
    for (let i = 0, len = lines.length; i < len; i++) {
        ret = lines[i];
        if (ret.indexOf('winConsole') > -1 && i < len - 1) {
            ret = lines[i + 1];
            break;
        }
    }
    return ret;
}
