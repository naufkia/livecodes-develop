"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Simple version for stringify, used for displaying object abstract.
const escape_1 = __importDefault(require("licia/escape"));
const toStr_1 = __importDefault(require("licia/toStr"));
const contain_1 = __importDefault(require("licia/contain"));
const startWith_1 = __importDefault(require("licia/startWith"));
const escapeJsStr_1 = __importDefault(require("licia/escapeJsStr"));
const each_1 = __importDefault(require("licia/each"));
const endWith_1 = __importDefault(require("licia/endWith"));
const isEmpty_1 = __importDefault(require("licia/isEmpty"));
const util_1 = require("./util");
const util_2 = require("../share/util");
const c = util_2.classPrefix('console');
// Modified from: https://jsconsole.com/
function getAbstract(obj, { topObj, level = 0, getterVal = false, unenumerable = true, } = {}) {
    let json = '';
    let type = '';
    const keyNum = 5;
    const parts = [];
    let names = [];
    let objEllipsis = '';
    const circular = false;
    let i;
    topObj = topObj || obj;
    const passOpts = { getterVal, unenumerable, level: level + 1 };
    const doStringify = level === 0;
    const keyWrapper = `<span class="${c('key')}">`;
    const numWrapper = `<span class="${c('number')}">`;
    const nullWrapper = `<span class="${c('null')}">`;
    const strWrapper = `<span class="${c('string')}">`;
    const boolWrapper = `<span class="${c('boolean')}">`;
    const specialWrapper = `<span class="${c('special')}">`;
    const strEscape = (str) => escape_1.default(str)
        .replace(/\\n/g, '↵')
        .replace(/\\f|\\r|\\t/g, '')
        .replace(/\\/g, '');
    const wrapperEnd = '</span>';
    const wrapKey = (key) => keyWrapper + strEscape(key) + wrapperEnd;
    const wrapNum = (num) => numWrapper + num + wrapperEnd;
    const wrapRegExp = (str) => strWrapper + str + wrapperEnd;
    const wrapBool = (bool) => boolWrapper + bool + wrapperEnd;
    const wrapNull = (str) => nullWrapper + str + wrapperEnd;
    function wrapStr(str) {
        str = toStr_1.default(str);
        if (contain_1.default(SPECIAL_VAL, str) || startWith_1.default(str, 'Array[')) {
            return specialWrapper + strEscape(str) + wrapperEnd;
        }
        return strWrapper + strEscape(`"${str}"`) + wrapperEnd;
    }
    function objIteratee(name) {
        if (i > keyNum) {
            objEllipsis = ', …';
            return;
        }
        const key = wrapKey(escapeJsonStr(name));
        if (!getterVal) {
            const descriptor = Object.getOwnPropertyDescriptor(obj, name);
            if (descriptor && descriptor.get) {
                parts.push(`${key}: ${wrapStr('(...)')}`);
                i++;
                return;
            }
        }
        parts.push(`${key}: ${getAbstract(topObj[name], passOpts)}`);
        i++;
    }
    try {
        type = {}.toString.call(obj);
    }
    catch (e) {
        type = '[object Object]';
    }
    const isStr = type == '[object String]';
    const isArr = type == '[object Array]';
    const isObj = type == '[object Object]';
    const isNum = type == '[object Number]';
    const isRegExp = type == '[object RegExp]';
    const isSymbol = type == '[object Symbol]';
    const isFn = type == '[object Function]';
    const isBool = type == '[object Boolean]';
    if (circular) {
        json = wrapStr('[circular]');
    }
    else if (isStr) {
        json = wrapStr(escapeJsonStr(obj));
    }
    else if (isRegExp) {
        json = wrapRegExp(escapeJsonStr(obj.toString()));
    }
    else if (isFn) {
        json = wrapStr('ƒ');
    }
    else if (isArr) {
        if (doStringify) {
            json = '[';
            let len = obj.length;
            let arrEllipsis = '';
            if (len > 100) {
                len = 100;
                arrEllipsis = ', …';
            }
            for (let i = 0; i < len; i++) {
                parts.push(`${getAbstract(obj[i], passOpts)}`);
            }
            json += parts.join(', ') + arrEllipsis + ']';
        }
        else {
            json = `Array(${obj.length})`;
        }
    }
    else if (isObj) {
        if (canBeProto(obj)) {
            obj = Object.getPrototypeOf(obj);
        }
        names = unenumerable ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        if (doStringify) {
            i = 1;
            json = '{';
            each_1.default(names, objIteratee);
            json += parts.join(', ') + objEllipsis + '}';
        }
        else {
            json = util_1.getObjType(obj);
            if (json === 'Object')
                json = '{…}';
        }
    }
    else if (isNum) {
        json = obj + '';
        if (endWith_1.default(json, 'Infinity') || json === 'NaN') {
            json = `"${json}"`;
        }
        else {
            json = wrapNum(json);
        }
    }
    else if (isBool) {
        json = wrapBool(obj ? 'true' : 'false');
    }
    else if (obj === null) {
        json = wrapNull('null');
    }
    else if (isSymbol) {
        json = wrapStr('Symbol');
    }
    else if (obj === undefined) {
        json = wrapStr('undefined');
    }
    else {
        try {
            if (canBeProto(obj)) {
                obj = Object.getPrototypeOf(obj);
            }
            if (doStringify) {
                i = 1;
                json = '{';
                names = unenumerable
                    ? Object.getOwnPropertyNames(obj)
                    : Object.keys(obj);
                each_1.default(names, objIteratee);
                json += parts.join(', ') + objEllipsis + '}';
            }
            else {
                json = util_1.getObjType(obj);
                if (json === 'Object')
                    json = '{…}';
            }
        }
        catch (e) {
            json = wrapStr(obj);
        }
    }
    return json;
}
exports.default = getAbstract;
const SPECIAL_VAL = ['(...)', 'undefined', 'Symbol', 'Object', 'ƒ'];
function canBeProto(obj) {
    const emptyObj = isEmpty_1.default(Object.getOwnPropertyNames(obj));
    const proto = Object.getPrototypeOf(obj);
    return emptyObj && proto && proto !== Object.prototype;
}
function escapeJsonStr(str) {
    return escapeJsStr_1.default(str).replace(/\\'/g, "'").replace(/\t/g, '\\t');
}
